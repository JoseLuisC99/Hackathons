import base64
import os
from datetime import datetime
from pathlib import Path
from typing import List

import gitlab
from google.adk.agents import LlmAgent

GITLAB_URL = os.environ.get("GITLAB_URL", "https://gitlab.com")
PRIVATE_TOKEN = os.environ.get("GITLAB_PRIVATE_TOKEN")
PROJECT_ID = os.environ.get("GITLAB_PROJECT_ID")

TARGET_BRANCH = "main"
COMMIT_MESSAGE = f"Automated: Update {datetime.now().strftime('%Y%m%d%H%M%S')} OpenAPI generated by ADK"
AUTHOR_NAME = "ADK Agent"
AUTHOR_EMAIL = "adk-bot@example.com"

GENERATED_SERVER_STUB_DIR = "scholarly_reports_server_stub_python_flask_vv1"
GENERATED_SDK_DIR = "scholarly_reports_client_sdk_python_vv1"


def get_project():
    if not PRIVATE_TOKEN or not PROJECT_ID:
        raise EnvironmentError("Error: GITLAB_PRIVATE_TOKEN and GITLAB_PROJECT_ID environment variables must be set.")

    gl = gitlab.Gitlab(GITLAB_URL, private_token=PRIVATE_TOKEN)
    try:
        return gl.projects.get(PROJECT_ID)
    except gitlab.exceptions.GitlabError as e:
        raise EnvironmentError(f"Error connecting to GitLab or finding project: {e}")

def collect_file_actions(directory_path, action_type="create"):
    actions = []
    base_path = Path(directory_path)
    if not base_path.exists() or not base_path.is_dir():
        print(f"Warning: Directory '{directory_path}' does not exist or is not a directory. Skipping.")
        return []

    for file_path in base_path.rglob("*"):
        if file_path.is_file():
            relative_path = file_path.relative_to(base_path.parent)  # Get path relative to the root of the repo
            try:
                with open(file_path, "rb") as f:
                    content_bytes = f.read()

                if b'\0' in content_bytes:
                    content = base64.b64encode(content_bytes).decode("utf-8")
                    encoding = "base64"
                else:
                    content = content_bytes.decode("utf-8")
                    encoding = "text"

                action = {
                    "action": action_type,
                    "file_path": str(relative_path),
                    "content": content,
                }
                if encoding == "base64":
                    action["encoding"] = "base64"
                actions.append(action)
                print(f"Prepared action '{action_type}' for: {relative_path}")
            except Exception as e:
                print(f"Error processing file {file_path}: {e}")
    return actions

def automate_gitlab_commit(directories_names: List[str]):
    """Commit and merge path in a GitLab project.

    Parameters:
        - directories_names: List of only directories names to commit (without the absolut path)

    Returns:
        dict: a dictionary with the commit and merge info
    """
    project = get_project()
    actions = []
    for directory in directories_names:
        actions += collect_file_actions(f"{os.getenv('API_REQUIREMENTS_PATH')}/{directory}", action_type="create")

    if not actions:
        return {"commited": False, "message": "No files collected for commit"}

    new_branch_name = f"adk-agent-update-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    project.branches.create({'branch': new_branch_name, 'ref': TARGET_BRANCH})
    branch_to_commit_to = new_branch_name

    try:
        commit_data = {
            'branch': branch_to_commit_to,
            'commit_message': COMMIT_MESSAGE,
            'actions': actions,
            'author_name': AUTHOR_NAME,
            'author_email': AUTHOR_EMAIL
        }
        commit = project.commits.create(commit_data)
        print(f"Commit created successfully! SHA: {commit.id}")
        print(f"Commit URL: {project.web_url}/-/commit/{commit.id}")

        try:
            pr_title = f"ADK Update: {commit.short_id}"
            pr_description = f"Automated update of on OpenAPI spec.\n\nCommit SHA: {commit.id}"

            mr = project.mergerequests.create({
                'source_branch': branch_to_commit_to,
                'target_branch': project.default_branch,
                'title': pr_title,
                'description': pr_description,
                'remove_source_branch': True,
            })
            return {"commited": True, "message": f"Pull Request created successfully. Commit URL: {project.web_url}/-/commit/{commit.id}, Pull Request URL: {mr.web_url}"}
        except gitlab.exceptions.GitlabError as e:
            return {"commited": False, "message": f"Error creating Pull Request: {e}"}

    except gitlab.exceptions.GitlabError as e:
        return {"commited": False, "message": f"Error creating commit: {e}"}


DEPLOYMENT_DESCRIPTION = "This agent commits and merges a validated OpenAPI stubs, SDKs, and docs generated assets into a designated GitLab project."

DEPLOYMENT_INSTRUCTIONS = """
Your task is to commit all specified generated assets to a GitLab repository using the commit_and_merge_api tool.
Read state["stub_directory"], state["sdk_directories"], and state["docs_directory"] and commit al these folders in the 
GitLab repository using your tool.

Set state["gitlab_mr_url"] with the URL of the merge request.
"""

class DeploymentAgent:
    @staticmethod
    def get_agent():
        return LlmAgent(
            name="deployer",
            model=os.getenv("LLM_MODEL"),
            description=DEPLOYMENT_DESCRIPTION,
            instruction=DEPLOYMENT_INSTRUCTIONS,
            tools=[automate_gitlab_commit],
            output_key="gitlab_mr_url"
        )